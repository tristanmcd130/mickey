# stdlib.mks already included due to mickey/main.ml

fun abs(x: int): int {
	if(x < 0)
		-x
	else
		x
}

fun mul(x: int, y: int): int {
	var result: int = 0;
	while(y != 0) {
		result = result + x;
		y = y - 1
	};
	result
}

fun div(x: int, y: int): int {
	var abs_x: int = abs(x);
	var abs_y: int = abs(y);
	var result: int = 0;
	if(y == 0)
		abort("Cannot divide by 0");
	while(abs_x >= abs_y) {
		abs_x = abs_x - abs_y;
		result = result + 1
	};
	if((x < 0) != (y < 0))
		result = -result;
	result
}

fun chr(x: int): char {
	x as char
}

fun code(x: char): int {
	x as int
}

fun print(msg: char ptr): unit {
	var x: char ptr = msg;
	while(!x != chr(0)) {
		!(4094 as char ptr) = !x;
		x = (x as int + 1) as char ptr
	}
}

fun readchar(): char {
	while(!(4093 as char ptr) != '\n') ();
	!(4092 as char ptr) 
}

fun readline(buffer: char ptr, limit: int): unit {
	var i: int = 0;
	var c: char = chr(0);
	var done: bool = false;
	while(i < limit - 1 and not done) {
		c = readchar();
		if(c == '\n')
			done = true
		else {
			buffer[i] = c;
			i = i + 1
		}
	};
	buffer[i] = chr(0)
}

fun abort(msg: char ptr): unit {
	print("Error: ");
	print(msg);
	print("\n");
	break(())
}

sig heap_start: int ptr

# struct block {
# 	bool inUse; // make inUse the top bit of size, then you can test for negative
# 	int size; // really more like capacity
# 	block *next;
# 	int data[size];
# }
# 
# block *firstBlock = &{false, 2048, NULL, {0}};
# 
# block *alloc(int size) {
# 	for(block *b = firstBlock; b != NULL; b = b->next) {
# 		if(!b->inUse && b->size >= size) {
# 			if(b->size >= 4) {
# 				// only split if its worth it
# 				//         SNDDDD
# 				// becomes SNDSND
# 				b[2 + size] = false + (b->size - 2); // not in use, 2 words lost due to new inUse/size and next
# 				b[3 + size] = NULL;
# 				b->size = size;
# 				b->next = b + 2 + size;
# 			}
# 			b->inUse = true;
# 			return b;
# 		}
# 	}
# 	return NULL;
# }

fun alloc(size: int): int ptr {
	var block: int ptr = heap_start;
	var found: bool = false;
	while(not found and block != 0 as int ptr) {
		if(!block >= size) {
			# print("FOUND SUITABLE BLOCK\n");
			if(!block >= 4) {
				# print("SPLITTING BLOCK\n");
				!((block as int + 2 + size) as int ptr) = !block - 2 - size;
				!((block as int + 3 + size) as int ptr) = 0;
				!block = size;
				!((block as int + 1) as int ptr) = block as int + 2 + size
			};
			!block = !block + -32768;
			found = true
		};
		if(not found) {
			# print("BLOCK NOT FOUND\n");
			block = !((block as int + 1) as int ptr ptr)
		}
	};
	if(block == 0 as int ptr)
		abort("Unable to allocate block");
	(block as int + 2) as int ptr
}

fun free(block: int ptr): unit {
	if(!((block as int - 2) as int ptr) > 0)
		abort("Block already freed")
	else
		!((block as int - 2) as int ptr) = !((block as int - 2) as int ptr) - -32768
		# try consolidating here?
}