// stdlib.mks already included due to mickey/main.ml

fun abs(x: int): int {
	if(x < 0)
		-x
	else
		x
}

fun _mul(x: int, y: int): int {
	var result: int = 0;
	while(y != 0) {
		result = result + x;
		y = y - 1
	};
	result
}

fun _div(x: int, y: int): int {
	var abs_x: int = abs(x);
	var abs_y: int = abs(y);
	var result: int = 0;
	if(y == 0)
		abort("Cannot divide by 0");
	while(abs_x >= abs_y) {
		abs_x = abs_x - abs_y;
		result = result + 1
	};
	if((x < 0) != (y < 0))
		result = -result;
	result
}

fun _mod(x: int, y: int): int {
	x - x/y * y
}

fun print(msg: char ptr): unit {
	var x: char ptr = msg;
	while(x[0] != 0 as char) {
		(4094 as char ptr)[0] = x[0];
		x = (x as int + 1) as char ptr
	}
}

fun printchar(msg: char): unit {
	(4094 as char ptr)[0] = msg
}

fun println(msg: char ptr): unit {
	print(msg);
	(4094 as char ptr)[0] = '\n'
}

fun readchar(): char {
	while((4093 as char ptr)[0] != '\n') ();
	(4092 as char ptr)[0]
}

fun read(buffer: char ptr, limit: int): unit {
	var i: int = 0;
	var c: char = 0 as char;
	var done: bool = false;
	while(i < limit - 1 & !done) {
		c = readchar();
		if(c == '\n')
			done = true
		else {
			buffer[i] = c;
			i = i + 1
		}
	};
	buffer[i] = 0 as char
}

fun abort(msg: char ptr): unit {
	print("Error: ");
	println(msg);
	break(())
}

sig heap_start: int ptr

// struct block {
// 	bool inUse; // make inUse the top bit of size, then you can test for negative
// 	int size; // really more like capacity
// 	block *next;
// 	int data[size];
// }
// 
// block *firstBlock = &{false, 2048, NULL, {0}};
// 
// block *alloc(int size) {
// 	for(block *b = firstBlock; b != NULL; b = b->next) {
// 		if(!b->inUse && b->size >= size) {
// 			if(b->size >= 4) {
// 				// only split if its worth it
// 				//         SNDDDD
// 				// becomes SNDSND
// 				b[2 + size] = false + (b->size - 2); // !in use, 2 words lost due to new inUse/size & next
// 				b[3 + size] = NULL;
// 				b->size = size;
// 				b->next = b + 2 + size;
// 			}
// 			b->inUse = true;
// 			return b;
// 		}
// 	}
// 	return NULL;
// }

var result: char ptr = "     0"
var digits: char ptr = "0123456789"

fun int_to_str(x: int): char ptr {
	var i: int = 5;
	var negative: bool = x < 0;
	result[5] = '0';
	x = abs(x);
	while(x > 0) {
		result[i] = digits[x % 10];
		// printchar(digits[x % 10]);
		x = x / 10;
		i = i - 1
	};
	if(negative) {
		result[i] = '-';
		i = i - 1
	};
	if(!(i == 5 & result[i] == '0'))
		i = i + 1;
	(result as int + i) as char ptr
}

fun heap_report(): unit {
	var p: int ptr = heap_start;
	var i: int = 0;
	while(p != 0 as int ptr) {
		print(int_to_str(p as int));
		print(": \nIn use: ");
		println(if(p[0] < 0) "yes" else "no");
		print("Size: ");
		println(int_to_str(if(p[0] < 0) p[0] - -32768 else p[0]));
		if(p[0] < 0) {
			i = 0;
			while(i < p[0] - -32768) {
				println(int_to_str(p[i + 2]));
				i = i + 1
			}
		};
		println("");
		p = p[1] as int ptr
	}
}

fun alloc(size: int): int ptr {
	var block: int ptr = heap_start;
	var found: bool = false;
	while(!found & block != 0 as int ptr) {
		if(block[0] >= size) {
			// print("FOUND SUITABLE AT ");
			// print(int_to_str(block as int));
			// println("");
			if(block[0] >= 4) {
				// println("SPLITTING BLOCK");
				block[2 + size] = block[0] - 2 - size;
				block[3 + size] = 0;
				block[0] = size;
				block[1] = block as int + 2 + size
			};
			block[0] = block[0] + -32768;
			found = true
		};
		if(!found) {
			// println("BLOCK NOT FOUND");
			block = (block as int ptr ptr)[1]
		}
	};
	if(block == 0 as int ptr)
		abort("Unable to allocate block");
	// println("ALLOC RETURN");
	(block as int + 2) as int ptr
}

fun free(block: int ptr): unit {
	var b: int ptr = (block as int - 2) as int ptr;
	if(block[-2] >= 0)
		abort("Block already freed")
	else {
		block[-2] = block[-2] - -32768;
		while((b[1] as int ptr)[0] < 0) {
			b[0] = b[0] + 2 + (b[1] as int ptr)[0];
			b[1] = (b[1] as int ptr)[1]
		}
	}
}

fun copy(src: int ptr, dst: int ptr, length: int): unit {
	var i: int = 0;
	while(i < length) {
		dst[i] = src[i];
		i = i + 1
	}
}

fun str_length(str: char ptr): int {
	var i: int = 0;
	while(str[i] != 0 as char)
		i = i + 1;
	i
}