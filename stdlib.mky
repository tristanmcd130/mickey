// stdlib.mks already included due to mickey/main.ml

fun abs(x: int): int {
	if(x < 0)
		-x
	else
		x
}

fun mul(x: int, y: int): int {
	var result: int = 0;
	while(y != 0) {
		result = result + x;
		y = y - 1
	};
	result
}

fun div(x: int, y: int): int {
	var abs_x: int = abs(x);
	var abs_y: int = abs(y);
	var result: int = 0;
	if(y == 0)
		abort("Cannot divide by 0");
	while(abs_x >= abs_y) {
		abs_x = abs_x - abs_y;
		result = result + 1
	};
	if((x < 0) != (y < 0))
		result = -result;
	result
}

fun mod(x: int, y: int): int {
	x - x/y * y
}

fun print(msg: char ptr): unit {
	var x: char ptr = msg;
	while(!x != 0 as char) {
		!(4094 as char ptr) = !x;
		x = (x as int + 1) as char ptr
	}
}

fun printline(msg: char ptr): unit {
	print(msg);
	!(4094 as char ptr) = '\n'
}

fun readchar(): char {
	while(!(4093 as char ptr) != '\n') ();
	!(4092 as char ptr) 
}

fun readline(buffer: char ptr, limit: int): unit {
	var i: int = 0;
	var c: char = 0 as char;
	var done: bool = false;
	while(i < limit - 1 and not done) {
		c = readchar();
		if(c == '\n')
			done = true
		else {
			buffer[i] = c;
			i = i + 1
		}
	};
	buffer[i] = 0 as char
}

fun abort(msg: char ptr): unit {
	print("Error: ");
	printline(msg);
	break(())
}

sig heap_start: int ptr

// struct block {
// 	bool inUse; // make inUse the top bit of size, then you can test for negative
// 	int size; // really more like capacity
// 	block *next;
// 	int data[size];
// }
// 
// block *firstBlock = &{false, 2048, NULL, {0}};
// 
// block *alloc(int size) {
// 	for(block *b = firstBlock; b != NULL; b = b->next) {
// 		if(!b->inUse && b->size >= size) {
// 			if(b->size >= 4) {
// 				// only split if its worth it
// 				//         SNDDDD
// 				// becomes SNDSND
// 				b[2 + size] = false + (b->size - 2); // not in use, 2 words lost due to new inUse/size and next
// 				b[3 + size] = NULL;
// 				b->size = size;
// 				b->next = b + 2 + size;
// 			}
// 			b->inUse = true;
// 			return b;
// 		}
// 	}
// 	return NULL;
// }

fun int_to_string(x: int): char ptr {
	var result: char ptr = "     0";
	var digits: char ptr = "0123456789";
	var i: int = 5;
	var negative: bool = x < 0;
	x = abs(x);
	while(x > 0) {
		result[i] = digits[x % 10];
		x = x / 10;
		i = i - 1
	};
	if(negative) {
		result[i] = '-';
		i = i - 1
	};
	if(not (i == 5 and result[i] == '0'))
		i = i + 1;
	(result as int + i) as char ptr
}

fun heap_report(): unit {
	var p: int ptr = heap_start;
	while(p != 0 as int ptr) {
		print(int_to_string(p as int));
		print(": \nIn use: ");
		printline(if(p[0] < 0) "yes" else "no");
		print("Size: ");
		printline(int_to_string(if(p[0] < 0) p[0] - -32768 else p[0]));
		printline("");
		p = p[1] as int ptr
	}
}

fun alloc(size: int): int ptr {
	var block: int ptr = heap_start;
	var found: bool = false;
	while(not found and block != 0 as int ptr) {
		if(!block >= 0 and !block >= size) {
			// printline("FOUND SUITABLE BLOCK");
			if(!block >= 4) {
				// printline("SPLITTING BLOCK");
				block[2 + size] = !block - 2 - size;
				block[3 + size] = 0;
				block[0] = size;
				block[1] = block as int + 2 + size
			};
			block[0] = block[0] + -32768;
			found = true
		};
		if(not found) {
			// printline("BLOCK NOT FOUND");
			block = !((block as int + 1) as int ptr ptr)
		}
	};
	if(block == 0 as int ptr)
		abort("Unable to allocate block");
	// printline("ALLOC RETURN");
	(block as int + 2) as int ptr
}

fun free(block: int ptr): unit {
	if(block[-2] > 0)
		abort("Block already freed")
	else {
		block[-2] = block[-2] - -32768
		// try consolidating here?
	}
}

fun copy(src: int ptr, dst: int ptr, length: int): unit {
	var i: int = 0;
	while(i < length) {
		dst[i] = src[i];
		i = i + 1
	}
}

fun string_length(str: char ptr): int {
	var i: int = 0;
	while(str[i] != 0 as char)
		i = i + 1;
	i
}